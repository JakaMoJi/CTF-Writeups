# CTF-Writeups

**CTF Challenge Write-Up: Sequence**

Challenge Description
Name: Sequence
Description:
Decrypt the encrypted message using the provided Syracuse seed and send back the original message to claim your victory!

Connection Details:
nc 13.36.237.1 12345

A Python script was provided with the challenge, containing the following code:

```python
def syracuse_sequence(n):
    sequence = []
    while n != 1:
        sequence.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    sequence.append(1)  
    return sequence

def encrypt(message, seed):
    sequence = syracuse_sequence(seed)
    alphanumeric_chars = string.ascii_letters + string.digits
    encrypted_message = []
    
    for i, char in enumerate(message):
        if char in alphanumeric_chars:
            original_index = alphanumeric_chars.index(char)
            shift_value = sequence[i % len(sequence)]
            new_index = (original_index + shift_value) % len(alphanumeric_chars)
            encrypted_char = alphanumeric_chars[new_index]
            encrypted_message.append(encrypted_char)
        else:
            encrypted_message.append(char)  
    
    return ''.join(encrypted_message)
```




Solution

**Step 1: Connecting with Netcat**

First, I connected to the provided IP address and port using netcat:

![image](https://github.com/JakaMoJi/CTF-Writeups/assets/75013863/54269d75-91f2-4290-9924-7c55ebee58b8)


**Step 2: Analyzing the Python Script**


To decrypt the message, I needed to understand and reverse the encryption algorithm. The encryption function uses a sequence generated by the syracuse_sequence function and applies a character shift based on this sequence.

**Step 3: Modifying the Script for Decryption**


I modified the encryption function to create a decryption function. 

Here is the modified script with explanations:

```python

import string

def syracuse_sequence(n):
    sequence = []
    while n != 1:
        sequence.append(n)
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    sequence.append(1)  
    return sequence

def decrypt(encrypted_message, seed):
    sequence = syracuse_sequence(seed)
    alphanumeric_chars = string.ascii_letters + string.digits
    decrypted_message = []

    for i, char in enumerate(encrypted_message):
        if char in alphanumeric_chars:
            original_index = alphanumeric_chars.index(char)
            shift_value = sequence[i % len(sequence)]
            new_index = (original_index - shift_value) % len(alphanumeric_chars)
            decrypted_char = alphanumeric_chars[new_index]
            decrypted_message.append(decrypted_char)
        else:
            decrypted_message.append(char)

    return ''.join(decrypted_message)

encrypted_message = "1iu_9yg_S5RmU_0Dc0?!"
seed = 87

decrypted_message = decrypt(encrypted_message, seed)
print("Decrypted message:", decrypted_message)


```



Explanation:

- The decrypt function mirrors the encrypt function.
- Instead of adding the shift value to the original index, it subtracts the shift value from the encrypted index.
- This reverse operation retrieves the original character positions.


**Step 4: Decrypting the Message**


the output of the code was this:
Decrypted message: C4n_Y0u_Gu3ss_Th1s?!

**Step 5: Submitting the Flag**


The decrypted message looked like a flag, so I wrapped it in the standard flag format:
flag{C4n_Y0u_Gu3ss_Th1s?!}
I submitted this flag, but it didn't work.

**Step 6: Sending the Decrypted Message via Netcat**


Next, I tried sending the decrypted message **(C4n_Y0u_Gu3ss_Th1s?!)** directly through the netcat connection:
In response, I received the actual flag from the server.


This concludes the write-up for the "Sequence" CTF challenge. The key steps involved connecting to the server, analyzing and modifying the provided script to decrypt the message, and then submitting the decrypted message to obtain the flag.





